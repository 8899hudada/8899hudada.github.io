{"meta":{"title":"胡大大的博客","subtitle":"大前端的铺路石","description":"乐观 积极 快","author":"胡大大","url":"https://8899hudada.github.io"},"pages":[],"posts":[{"title":"vue 内部运行机制","slug":"vue-内部运行机制","date":"2018-06-11T03:40:50.000Z","updated":"2018-06-11T06:00:47.152Z","comments":true,"path":"2018/06/11/vue-内部运行机制/","link":"","permalink":"https://8899hudada.github.io/2018/06/11/vue-内部运行机制/","excerpt":"","text":"1. new Vue() new Vue() 后， Vue 会调用 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」 2. compile 三个阶段 parse：正则等方式解析 template 模板中的指令、class、style等数据，形成AST(抽象语法树)。optimize：标记 static 静态节点—更新界面时，会有一个 patch 的过程， diff 算法会直接跳过静态节点generate：将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串在经历过 parse、optimize 与 generate 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了，用getter函数进行依赖收集 3. 响应式 对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数依赖收集的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者Dep 的 subs 中值改变 =&gt; 触发setter =&gt; 通知依赖收集的每一个watch =&gt; patch到需要改变的那个watcher =&gt; 调用update来更新视图 响应式系统: Object.defineProperty(obj, prop, descriptor)descriptor: enumerable configurable get set 123456789101112131415161718192021222324252627282930313233343536373839404142function cb() &#123; /* 渲染视图 */ console.log(&quot;视图更新啦～&quot;);&#125;function defineReactive(obj, key, val) &#123; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; return val; &#125;, set: function reactiveSetter(newVal) &#123; if ( newVal === val) return cb(newVal); &#125; &#125;)&#125;function observer(value) &#123; if (!value || (typeof value !== &apos;Object&apos;)) &#123; return &#125; Object.keys(value).forEach((key) =&gt; &#123; defineReactive(value, key, value[key]) &#125;)&#125;class Vue &#123; constructor(options) &#123; this._data = options.data observer(this._data) &#125;&#125;let o = new Vue(&#123; data: &#123; test: &apos;hello world&apos; &#125;&#125;)o._data.test = &apos;hello opensive&apos; 4. Virtual DOM render function() （VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象 5. 更新视图 将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的「差异」。最后我们只需要将这些「差异」的对应 DOM 进行修改即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//订阅者 Depclass Dep &#123; constructor () &#123; /* 用来存放Watcher对象的数组 */ this.subs = []; &#125; /* 在subs中添加一个Watcher对象 */ addSub (sub) &#123; this.subs.push(sub); &#125; /* 通知所有Watcher对象更新视图 */ notify () &#123; this.subs.forEach((sub) =&gt; &#123; sub.update(); &#125;) &#125;&#125;//观察者 Watcherclass Watcher &#123; constructor () &#123; /* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */ Dep.target = this; &#125; /* 更新视图的方法 */ update () &#123; console.log(&quot;视图更新啦～&quot;); &#125;&#125;Dep.target = null;//依赖收集function defineReactive (obj, key, val) &#123; /* 一个Dep类对象 */ const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; /* 将Dep.target（即当前的Watcher对象存入dep的subs中） */ dep.addSub(Dep.target); return val; &#125;, set: function reactiveSetter (newVal) &#123; if (newVal === val) return; /* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */ dep.notify(); &#125; &#125;);&#125;class Vue &#123; constructor(options) &#123; this._data = options.data; observer(this._data); /* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */ new Watcher(); /* 在这里模拟render的过程，为了触发test属性的get函数 */ console.log(&apos;render~&apos;, this._data.test); &#125;&#125; 6.Vuex dispatch =&gt; actions(…mapActions({}))commit =&gt; mutations (mutation-types.js SOME_MUTATION{} …mapMutations([]))mutate =&gt; State(…mapState({})) getters(…mapGetters([]))","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://8899hudada.github.io/tags/vue/"}]},{"title":"css init","slug":"css-init","date":"2018-06-04T03:51:29.000Z","updated":"2018-06-11T04:50:28.984Z","comments":true,"path":"2018/06/04/css-init/","link":"","permalink":"https://8899hudada.github.io/2018/06/04/css-init/","excerpt":"","text":"css 初始化为什么要初始化CSS？ 建站老手都知道，这是为了考虑到浏览器的兼容问题，其实不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 最简单的初始化方法就是： {padding: 0; margin: 0;} 。有很多人也是这样写的。这确实很简单，但有人就会感到疑问：号这样一个通用符在编写代码的时候是快，但如果网站很大，CSS样式表文件很大，这样写的话，他会把所有的标签都初始化一遍，这样就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间。 写过css的都知道每个网页引进的css首先都需要初始化 CSS初始化是指重设浏览器的样式。不同的浏览器默认的样式可能不尽相同，所以开发时的第一件事可能就是如何把它们统一。如果没对CSS初始化往往会出现浏览器之间的页面差异。每次新开发网站或新网页时候通过初始化CSS样式的属性，为我们将用到的CSS或html标签更加方便准确，使得我们开发网页内容时更加方便简洁，同时减少CSS代码量，节约网页下载时间。 雅虎工程师提供的CSS初始化示例代码123456789101112131415body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px; &#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption, cite, code, dfn, em, strong, th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none; &#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123;overflow-y: scroll;&#125;.clearfix:after &#123;content: &quot;.&quot;; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; 腾讯官网 样式初始化123456789body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select&#123;margin:0;padding:0&#125;body&#123;font:12px&quot;宋体&quot;,&quot;Arial Narrow&quot;,HELVETICA;background:#fff;-webkit-text-size-adjust:100%;&#125;a&#123;color:#2d374b;text-decoration:none&#125;a:hover&#123;color:#cd0200;text-decoration:underline&#125;em&#123;font-style:normal&#125;li&#123;list-style:none&#125;img&#123;border:0;vertical-align:middle&#125;table&#123;border-collapse:collapse;border-spacing:0&#125;p&#123;word-wrap:break-word&#125; 新浪官网 样式初始化12345678910body,ul,ol,li,p,h1,h2,h3,h4,h5,h6,form,fieldset,table,td,img,div&#123;margin:0;padding:0;border:0;&#125;body&#123;background:#fff;color:#333;font-size:12px; margin-top:5px;font-family:&quot;SimSun&quot;,&quot;宋体&quot;,&quot;Arial Narrow&quot;;&#125;ul,ol&#123;list-style-type:none;&#125;select,input,img,select&#123;vertical-align:middle;&#125;a&#123;text-decoration:none;&#125;a:link&#123;color:#009;&#125;a:visited&#123;color:#800080;&#125;a:hover,a:active,a:focus&#123;color:#c00;text-decoration:underline;&#125; 淘宝官网 样式初始化123456789101112131415body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \\5b8b\\4f53; &#125;h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;address, cite, dfn, em, var &#123; font-style:normal; &#125;code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;small&#123; font-size:12px; &#125;ul, ol &#123; list-style:none; &#125;a &#123; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;sup &#123; vertical-align:text-top; &#125;sub&#123; vertical-align:text-bottom; &#125;legend &#123; color:#000; &#125;fieldset, img &#123; border:0; &#125;button, input, select, textarea &#123; font-size:100%; &#125;table &#123; border-collapse:collapse; border-spacing:0; &#125; 网易官网 样式初始化123456789html &#123;overflow-y:scroll;&#125;body &#123;margin:0; padding:29px; font:12px&quot;\\5B8B\\4F53&quot;,sans-serif;background:#ffffff;&#125;div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p&#123;padding:0; margin:0;&#125;table,td,tr,th&#123;font-size:12px;&#125;li&#123;list-style-type:none;&#125;img&#123;vertical-align:top;border:0;&#125;ol,ul &#123;list-style:none;&#125;h1,h2,h3,h4,h5,h6&#123;font-size:12px; font-weight:normal;&#125;address,cite,code,em,th &#123;font-weight:normal; font-style:normal;&#125; 123456789101112131415&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;zh-cn&quot;&gt;&lt;head&gt; &lt;title&gt;网站标题 - Admin10000.com &lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot; /&gt; &lt;meta name=&quot;Author&quot; content=&quot;网页作者&quot; /&gt; &lt;meta name=&quot;Copyright&quot; content=&quot;网站版权&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;网站关键字&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;网站描述&quot; /&gt; &lt;link rel=&quot;Shortcut Icon&quot; href=&quot;网站.ico图标路径&quot; /&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;CSS文件路径&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;JS文件路径&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://8899hudada.github.io/tags/css/"}]},{"title":"从url输入到页面加载的过程--完善前端体系","slug":"从url输入到页面加载的过程-完善前端体系","date":"2018-06-04T03:37:25.000Z","updated":"2018-06-11T05:59:25.656Z","comments":true,"path":"2018/06/04/从url输入到页面加载的过程-完善前端体系/","link":"","permalink":"https://8899hudada.github.io/2018/06/04/从url输入到页面加载的过程-完善前端体系/","excerpt":"","text":"从输入URL到页面加载的过程? 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）Browser进程：浏览器的主进程（负责协调、主控），只有一个,浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）多线程的浏览器内核: GUI线程 JS引擎线程 事件触发线程 定时器线程 网络请求线程解析URL: protocol host port path query fragment 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）dns查询: 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host, 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP. 需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑 dns-prefetch优化。tcp/ip请求构建: http的本质就是 tcp/ip请求 , 三次握手 四次挥手（因为是全双工的，所以需要四次挥手）. get和post本质都是tcp/ip, get会产生一个tcp数据包，post两个。五层因特网协议栈: 应用层(dns,http) DNS解析成IP并发送http请求 传输层(tcp,udp) 建立tcp连接（三次握手） 网络层(IP,ARP) IP寻址 数据链路层(PPP) 封装成帧 物理层(利用物理介质传输比特流)物理传输（然后传输的时候通过双绞线，电磁波等各种介质） 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）简单的说：用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户。后台的处理: 一般有的后端是有统一的验证的，如安全拦截，跨域验证 , 如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）, 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等） ,等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）, 然后就是将这个包从后端发送到前端，完成交互 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）通用头部: 请求的web服务器地址 请求方式 请求的返回状态码 请求的远程服务器地址 200——表明该请求被成功地完成，所请求的资源发送回客户端 304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存 400——客户端请求有错（譬如可以是安全模块拦截） 401——请求未经授权 403——禁止访问（譬如可以是未登录时禁止） 404——资源未找到 500——服务器内部错误 503——服务不可用 1xx——指示信息，表示请求已接收，继续处理 2xx——成功，表示请求已被成功接收、理解、接受 3xx——重定向，要完成请求必须进行更进一步的操作 4xx——客户端错误，请求有语法错误或请求无法实现 5xx——服务器端错误，服务器未能实现合法的请求请求头部： Host请求的服务器URL 接收类型（对标服务端返回的Content-Type） Cookie Connection（如keep-alive） User-Agent响应头部：服务器端允许的请求Headers 请求方法 Origin头部 Content-Type Max-age Cache-Control Keep-Alive Server请求/响应体cookie以及优化： 浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。 cookie中设置 httponly（这样就无法通过js操作了） 优化： 将静态资源分组，分别放到不同的子域名下，而子域名请求时，是不会带上父级域名的cookie的，所以就避免了浪费http1.1起，默认使用长连接，使用长连接会有这一行 Connection:keep-alive 注意： keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效。简述下http2.0的一些特性：多路复用（即一个tcp/ip连接可以请求多个资源） 首部压缩 二进制分帧 服务器端推送 请求优先级 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）两种类型： 强缓存（ 200fromcache）与 协商缓存（ 304）E-tag相比Last-Modified？Last-Modified：表明服务端的文件最后何时改变的 它有一个缺陷就是只能精确到1s， 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效E-tag：是一种指纹机制，代表文件相关指纹 只有文件变才会变，也只要文件变就会变， 也没有精确时间的限制，只要文件一变，立马E-tag就不一样了 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）渲染步骤大致可以分为以下几步：解析HTML，构建DOM树 解析CSS，生成CSS规则树 合并DOM树和CSS规则，生成render树布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上 回流、重绘（offset(Top/Left/Width/Height) scroll(Top/Left/Width/Height) cilent(Top/Left/Width/Height) width,height 调用了getComputedStyle()或者IE的currentStyle）domcontentloaded：事件触发时，仅当DOM加载完成loaded：事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了 CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）如何触发BFC？ 元素 float属性不为none position为absolute或fixed display为inline-block,flex,inline-flex，table，table-cell，table-caption overflow不为 visibledisplay:table 它本身不产生BFC，但是它会产生匿名框（包含 display:table-cell的框），而这个匿名框产生BFC。 JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）JS引擎的处理过程可以简述如下：词法分析 =&gt; 词元 语法分析 =&gt; 语法树 翻译器=&gt; 将代码转为字节码 字节码解释器 =&gt; 机器码 最终计算机执行的就是机器码即时编译: 核心的 JIT编译器将源码编译成机器码运行GC时，停止响应其他操作， 避免GC造成的长时间停止响应。 分代回收: 多回收“临时对象”区 少回收“持久对象”区 减少每次需遍历的对象，从而减少每次GC的耗时 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）","categories":[],"tags":[{"name":"http js","slug":"http-js","permalink":"https://8899hudada.github.io/tags/http-js/"}]},{"title":"简单实现vue双向数据绑定","slug":"简单实现vue双向数据绑定","date":"2018-06-02T03:35:19.000Z","updated":"2018-06-11T03:36:26.780Z","comments":true,"path":"2018/06/02/简单实现vue双向数据绑定/","link":"","permalink":"https://8899hudada.github.io/2018/06/02/简单实现vue双向数据绑定/","excerpt":"","text":"1234&lt;div id=\"app\"&gt; &lt;input type=\"text\" id=\"txt\"&gt; &lt;p id=\"show-txt\"&gt;&lt;/p&gt;&lt;/div&gt; 12345678910111213var obj = &#123;&#125;Object.defineProperty(obj, 'txt', &#123; get: function () &#123; return obj &#125;, set: function (newVal) &#123; document.getElementById('txt').value = newVal document.getElementById('show-txt').innerHTML = newVal &#125;&#125;)document.addEventListener('keyup', function (e) &#123; obj.txt = e.target.value&#125;)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://8899hudada.github.io/tags/vue/"}]},{"title":"实现vue双向数据绑定","slug":"实现vue双向数据绑定","date":"2018-06-01T03:30:24.000Z","updated":"2018-06-11T05:59:40.196Z","comments":true,"path":"2018/06/01/实现vue双向数据绑定/","link":"","permalink":"https://8899hudada.github.io/2018/06/01/实现vue双向数据绑定/","excerpt":"","text":"myvue Object对象的defineProperty属性，重写data的set和get函数来实现的 123#app &#123; text-align: center;&#125; 1234567&lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button type=\"button\" v-click=\"increment\"&gt;添加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126function myVue(options) &#123; this._init(options);&#125;myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._binding = &#123;&#125;; this._obverse(this.$data); this._complie(this.$el);&#125;myVue.prototype._obverse = function (obj) &#123; var _this = this; Object.keys(obj).forEach(function (key) &#123; if (obj.hasOwnProperty(key)) &#123; _this._binding[key] = &#123; _directives: [] &#125;; console.log(_this._binding[key]) var value = obj[key]; if (typeof value === 'object') &#123; _this._obverse(value); &#125; var binding = _this._binding[key]; Object.defineProperty(_this.$data, key, &#123; enumerable: true, configurable: true, get: function () &#123; console.log(`$&#123;key&#125;获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`$&#123;key&#125;更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125;)&#125;myVue.prototype._complie = function (root) &#123; var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125;&#125;function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update();&#125;Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp];&#125;window.onload = function() &#123; var app = new myVue(&#123; el:'#app', data: &#123; number: 0, count: 0, &#125;, methods: &#123; increment: function() &#123; this.number ++; &#125;, incre: function() &#123; this.count ++; &#125; &#125; &#125;)&#125;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://8899hudada.github.io/tags/vue/"}]},{"title":"some 面试题","slug":"some-面试题","date":"2018-05-31T02:51:55.000Z","updated":"2018-06-11T06:10:00.136Z","comments":true,"path":"2018/05/31/some-面试题/","link":"","permalink":"https://8899hudada.github.io/2018/05/31/some-面试题/","excerpt":"","text":"比较新的面试题面试题 全局字体123body &#123; font-family: Microsoft Yahei, SimSun, Helvetica;&#125; 使用css实现一个持续的动画效果1234567@keyframes mymove &#123; from &#123;top: 0px;&#125; to &#123;top: 200px;&#125;&#125;p &#123; animation: mymove 5s infinite;&#125; 水平垂直居中12345678910111213141516171. transform: translate(-50%,-50%);2. margin:-50px 0 0 -50px;3. margin:auto;top:0;bottom:0;left:0;right:0;4. display:flex;justify-content:center;align-items: center; 多行文本溢出展示1234567891011p &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden;&#125;/*让图文不可复制*/p &#123; user-select: none;&#125; 1.跨域解决方案同源策略: 协议+域名+端口 防止XSS、CSFR等攻击 =&gt; httpOnly 跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 跨域解决方案 通过jsonp跨域 =&gt; 动态创建script jsonp缺点：只能实现get一种请求 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） 服务端设置Access-Control-Allow-Origin nginx代理跨域 nodejs中间件代理跨域 WebSocket协议跨域 2.输入URL到页面加载显示完成，这个过程中都发生了什么？url 浏览器缓存 &gt; 本地域名解析 &gt; 本地服务器DNS &gt; 远程DNS服务器 跨域处理 （查询服务器地址） 可能 负载均衡 CDN处理请求 建立TCP/IP连接 ssl同信 握手 数据传输 页面加载html css js image 渲染 Dom Cssom Rendom树 3.浏览器内核：主要分成两部分：渲染引擎 和 jS引擎4.编程范式: 面向过程 面向对象 函数式编程5.原型与原型链: Object.prototype的属性和方法 所有的引用类型（包括数组，对象，函数）都有隐性原型属性（proto）,值也是一个普通的对象作用域及闭包异步和单线程 import、require、export、module.exports关键在于 webpack_require 函数，这个函数就是 require 或者是 import 的替代 babel 在模块化的场景中充当了什么角色？以及 webpack ？哪个启到了关键作用？babel 能提前将 es6 的 import 等模块关键字转换成 commonjs 的规范。这样 webpack 就无需再做处理，直接使用 webpack 运行时定义的 webpack_require 处理。 为何有的地方使用 require 去引用一个模块时需要加上 default？ require(‘xx’).defaultbabel 对导出模块的转换，es6 的 export default 都会被转换成 exports.default，即使这个模块只有这一个输出 各大 UI 组件库时都会被介绍到为了避免引入全部文件，请使用 babel-plugin-component 等babel 插件import { Button, Select } from ‘element-ui’ commonjs / commonjs2exports[‘spon-ui’] =&gt; module.exports 面试流程题123456789101112131415161718&lt;p&gt; 1.自我介绍: 简单介绍学习及工作经历；针对所应聘的职位，介绍往期工作过程中和应聘职位相关的项目经验；用简单风趣的语言介绍一下自己的兴趣爱好，以及其他你认为有必要展示的信息 2.无领导小组讨论: 过程中，注意匹配职位要求进行发挥，如果你应聘服务岗，展现你的性格优势和服务意识，避免“针锋相对”；如果你应聘销售岗，展现你的说服力，而不是“被说服”；如果你应聘储备管理岗，展现你的领导意识，避免“随波逐流、人云亦云”…… 3.在你之前的工作经历中，比较成功的项目经验是什么？ 根据应聘岗位的性质，从以往的工作经历中选择匹配度较高、影响力较大的项目进行分析，引用数量、增长比、效果等数据进行展示更有说服力，如果能带一份原项目的总结报告参加面试将会更加分。 4.如果让你组织一次活动，你会如何处理？ 首先了解活动面向的客群、年龄段，针对客群的特殊性提出对应的活动方案。譬如，如果针对年轻群体，应该考虑提高活动的时尚度、举办时间安排在中午或晚上、宣传方式偏向网络渠道、场景搭建更有质感等细节问题。分析群体特征后，按照活动组织流程展开叙述。当然，如果带一份提前准备好的工作计划，即使与问题不完全相关，也可以让对方看到你为面试做了足够的准备，提升印象分。 5.最后自己有什么想问的：问下部门的技术栈、技术沙龙之类的，谢谢！ 负载均衡你了解吗？阐述一下 linux环境你熟悉吗？说一些你用过的指令 webpack了解吗？用过哪些功能 对css预编译器有所了解吗？ 完整概述一个你感觉最你自己做过最棒的项目？ 你在这个项目中用到了koa，那你能说说koa的特点是什么吗？ 有考虑过如何对项目进行优化吗？从那方面入手？ 为什么从上一家公司离职？ 希望能接触更大的发展平台,把自己的技术体系化 做出好的产品，技能涨工资 为什么选择我们公司？ 职业很符合，发展潜力大 你的薪资期望是？ 对公司的公正和实力表示肯定，并表示相信公司会根据行业水平给出合理的薪资。以询问的方式了解对方是否可以达到月薪x的行业均值（可以是自己的期望水平）。当然如果实在要说一个数据的话，最低可以在现有薪水的基础上提高35%-40%。 期望能给一个即使加班也能够打鸡血的工资&lt;/p&gt; 媒体查询引入1234567html&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;xxx.css&quot; media=&quot;only screen and (max-device-width:480px)&quot;&gt;css@media only screen and (max-device-width: 480px ) &#123; /*css样式*/&#125; 阐述一下CSS Sprites: background-image background- repeat background-positionconsole类型：123456console.log(&apos;文字信息&apos;); console.info(&apos;提示信息&apos;); console.warn(&apos;警告信息&apos;); console.error(&apos;错误信息&apos;);Console.group()和 Console.groupEnd()包裹分组内容console.table()可以将传入的对象，或数组以表格形式输出Console.dir()显示一个对象的所有属性和方法console.assert() 进行条件输出Console.time()和 Console.timeEnd()包裹需要计时的代码片段 vue 如何解析模板？第一步是将非结构化的模板字符串，转变成结构化的 JS 对象，抽象语法树，即 AST 。第二步，将 AST 转换成一个 render 函数，步骤是先转换为一段函数体的字符串，然后再用new Function(…)生成函数。第三部，渲染时执行 render 函数，返回虚拟 DOM 对象，然后执行虚拟 DOM 的patch方法，渲染成真正的 html 。vue内部渲染机制 React 的 setState 为何是异步渲染？为了防止一次性执行多次setState而带来的渲染性能问题。 hybrid 和 h5 有何区别？hybrid 是通过file协议加载的本地文件，h5是通过http协议加载的网络文件，前者速度快hybrid 是通过为不同版本打包进行更新，而 h5 没有版本的概念，每次都获取服务端的最新版hybrid 更加依赖于客户端的能力，因此会更多的和客户端通讯，而 h5 基本用不到和客户端通讯 :伪类 ::伪元素伪类: 用于选择DOM树之外的信息，或是不能用简单选择器进行表示的信息。前者包含那些匹配指定状态的元素，比如:visited，:active；后者包含那些满足一定逻辑条件的DOM树中的元素，比如:first-child，:first-of-type，：target 伪元素: 为DOM树没有定义的虚拟元素。不同于其他选择器，它不以元素为最小选择单元，它选择的是元素指定内容 123console.log(typeof NaN === &quot;number&quot;); // &quot;true&quot;console.log(0.1 + 0.2); // 0.30000000000000004console.log(0.1 + 0.2 === 0.3); // false 原生ajax12345678910var xhr = new XMLHttpRequest()xhr.open(&apos;GET&apos;, &apos;/list&apos;)xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;)xhr.send(&apos;hello ajax&apos;)xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125; Nodejs后台示例 (解决跨域)123456789101112131415161718192021222324252627var http = require(&apos;http&apos;)var server = http.createSever()var qs = require(&apos;querystring&apos;)server.on(&apos;request&apos;, function (req, res) &#123; var postData = &apos;&apos; // 数据块接收中 req.addListener(&apos;data&apos;, function (chunk) &#123; postData += chunk &#125;) // 数据块接收完毕 req.addListener(&apos;end&apos;, function () &#123; postData = qs.parse(postData) // 跨域后台设置 res.writeHead(200, &#123; &apos;Access-Control-Allow-Credentials&apos;:&apos;true&apos;,// 后端允许发送Cookie &apos;Access-Control-Allow-Origin&apos;:&apos;http://www.domain1.com&apos;,// 允许访问的域（协议+域名+端口） &apos;Set-Cookie&apos;:&apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;// HttpOnly:脚本无法读取cookie &#125;) res.write(JSON.stringify(postData)) res.end() &#125;)&#125;)server.listen(&apos;8080&apos;)console.log(&apos;server is running at port 8080...&apos;) 封装一个函数，参数是定时器的时间，.then执行回调函数123function sleep(time) &#123; return new Promise((resolve) =&gt; setTimeout(resolve, time))&#125; 事件委托12var oUl = document.getElementById(&apos;test&apos;); oUl.addEventListener(&apos;click&apos;, &apos;oUl btnClass&apos;,function(ev)&#123;&#125;) Set 和 Map 数据结构Set 它类似于数组 值都是唯一的Map 类似于对象，也是键值对的集合 快速的让一个数组乱序12345var arr = [1,2,3,4,5,6,7,8,9] arr.sort(() =&gt; &#123; return Math.random() - 0.5 &#125;) console.log(arr) 冒泡排序123456789101112131415function sort(arr) &#123; for (var i = 0; i&lt; arr.length-1;i++) &#123; for (var j=0; j&lt;arr.length -1 -i;j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; var temp = arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125; &#125;&#125;var arr = [3,1,7,5,2,4,9,6,10,8]console.log(arr)sort(arr)console.log(arr) 二分法查找二分法查找算法：采用二分法查找时，数据需是排好序的。主要思想是：（设查找的数组区间为array[s, e]）（1）确定该区间的中间位置m（2）将查找的值T与array[m]比较,若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。区域确定如下：这里设array从小到大排列,array[m]&gt;T由数组的有序性可知array[m,……,e]&gt;T;故新的区间为array[s,……，m-1],类似上面查找区间array[s,……，m-1]。每一次查找与中间值比较，判断是否查找成功，不成功当前查找区间缩小一半，循环查找，即可。时间复杂度:O(log2n)。1234567891011121314151617181920212223242526272829303132let arr = [0, 1, 2, 4, 5, 6, 7, 8];let arr2 = [88, 77, 66, 55, 44, 33, 22, 11];BinarySearch(arr2, 77);BinarySearch(arr, 2);function BinarySearch(arr, target) &#123; let s = 0; let e = arr.length - 1; let m = Math.floor((s + e) / 2); let sortTag = arr[s] &lt;= arr[e];//确定排序顺序 while (s &lt; e &amp;&amp; arr[m] !== target) &#123; if (arr[m] &gt; target) &#123; sortTag &amp;&amp; (e = m - 1); !sortTag &amp;&amp; (s = m + 1); &#125; else &#123; !sortTag &amp;&amp; (e = m - 1); sortTag &amp;&amp; (s = m + 1); &#125; m = Math.floor((s + e) / 2); &#125; if (arr[m] == target) &#123; console.log(&apos;找到了,位置%s&apos;, m); return m; &#125; else &#123; console.log(&apos;没找到&apos;); return -1; &#125;&#125; gulp12345678var gulp = require(&apos;gulp&apos;); gulp.src(&apos;script/jquery.js&apos;) .pipe(gulp.dest(&apos;dist/foo.js&apos;)); gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; //定义一个有依赖的任务 // Do something &#125;);","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://8899hudada.github.io/tags/面试/"}]},{"title":"杂记","slug":"杂记","date":"2018-05-30T02:29:09.000Z","updated":"2018-06-11T05:59:53.215Z","comments":true,"path":"2018/05/30/杂记/","link":"","permalink":"https://8899hudada.github.io/2018/05/30/杂记/","excerpt":"","text":"css序列123456789101112131415161718192021222324li &#123; color: red;&#125;li:first-child,li:nth-child(2n + 4),li:nth-child(3n + 6),li:nth-child(5n + 10),li:nth-child(7n + 14),li:nth-child(11n + 22),li:nth-child(13n + 26),li:nth-child(17n + 34),li:nth-child(19n + 38),li:nth-child(23n + 46),li:nth-child(29n + 58),li:nth-child(31n + 62) &#123; color: #ddd;&#125;&lt;!-- 文本末尾... --&gt;.hideInline &#123; text-overflow: ellipsis; white-space: nowrap; overflow: hidden;&#125; img srcset1&lt;img src=&quot;&quot; srcset=&quot;/static/logo_EN@2x.png 1x, /static/logo_EN@2x.png 2x, /static/logo_EN@3x.png 3x&quot;&gt; webpacka. 控制台显示打包结果: webpack –display-modules –sort-modules-by sizeb. 可视化分析依赖: webpack –profile –json &gt; stats.json (webpack analyse) ES6 Object 123456789const arr = [ 1, 2, 3, 4, NaN];//使用if(arr.includes(3))&#123; console.log(true);&#125;const cars = &#123; &apos;BMW&apos;: 3, &apos;Tesla&apos;: 2, &apos;Toyota&apos;: 1 &#125;;const values = Object.values(cars);console.log(values); // [3, 2, 1] padStart padEnd 12&apos;5&apos;.padStart(10) // &apos; 5&apos;&apos;5&apos;.padStart(10, &apos;=*&apos;) //&apos;=*=*=*=*=5&apos; async/await 123456789101112131415161718192021222324252627async function getAmount2(userId) &#123; var user = await getUser(userId); var amount = await getBankBalance(user); console.log(amount);&#125;getAmount(&apos;1&apos;); //$1,000getAmount2(&apos;1&apos;); //$1,000function getUser(userId) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;john&apos;) &#125;, 1000) &#125;);&#125;function getBankBalance(user) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if(user == &apos;john&apos;) &#123; resolve(&apos;$1,000&apos;); &#125; else &#123; reject(unknown user); &#125; &#125;, 1000) &#125;);&#125; 使用 try catch 1234567891011121314151617181920212223242526272829303132333435363738394041async function doubleAndAdd(a, b) &#123; try &#123; a = await doubleAfterlSec(a); b = await doubleAfterlSec(b); &#125; catch (e) &#123; return NaN; // return something &#125; return a + b;&#125;// 用法doubleAndAdd(&apos;one&apos;, 2).then(console.log) //NaNdoubleAndAdd(1, 2).then(console.log) // 6function doubleAfterlSec(param) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; let val = param * 2; isNaN(val) &gt; reject(NaN) : resolve(val); &#125;, 1000); &#125;);&#125;//Option 3 - 不要做任何事情，在function外捕获//因为异步/等待返回一个Promise，我们可以捕捉整个函数的错误async function doubleAndAdd(a, b) &#123; a = await doubleAfter1Sec(a); b = await doubleAfter1Sec(b); return a + b;&#125;//用法doubleAndAdd(&apos;one&apos;, 2) .then(console.log) .catch(console.log); // 👈👈🏼&lt;------- use &quot;catch&quot;function doubleAfter1Sec(param) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; let val = param * 2; isNaN(val) ? reject(NaN) : resolve(val); &#125;, 1000); &#125;);&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://8899hudada.github.io/tags/js/"}]},{"title":"http通信协议笔记","slug":"http通信协议","date":"2018-04-21T02:40:46.000Z","updated":"2018-06-11T06:00:08.987Z","comments":true,"path":"2018/04/21/http通信协议/","link":"","permalink":"https://8899hudada.github.io/2018/04/21/http通信协议/","excerpt":"","text":"1. 从Chrome源码看DNS解析过程客户端向域名解析服务器发起查询，然后服务器返回响应。DNS服务器nameservers是在设备接入网络的时候路由器通过DHCP发给设备的，chrome会按照nameservers的顺序发起查询，并将结果缓存，有效时间根据ttl，有效期内两次查询直接使用cache。DNS解析的结果有几种类型，最常见的是A记录和CNAME记录，A记录表示结果是一个IP地址，CNAME表示结果是另外一个域名 H5首屏秒开方案探讨：怎样减少白屏时间总结起来，大体优化思路就是：缓存/预加载/并行，缓存一切网络请求，尽量在用户打开之前就加载好所有内容，能并行做的事不串行做。 初始化 webview -&gt; 请求页面 -&gt; 下载数据 -&gt; 解析HTML -&gt; 请求 js/css 资源 -&gt; dom 渲染 -&gt; 解析 JS 执行 -&gt; JS 请求数据 -&gt; 解析渲染 -&gt; 下载渲染图片 前端优化： 降低请求量： 合并资源， 减少 HTTP 请求数， TCP &gt; 对称密钥 minify / gzip 压缩， webP， lazyLoad 加快请求速度： 预解析DNS =&gt; 浏览器 &gt; 本机层 &gt; 路由器缓存 &gt; 本地DNS服务器 &gt; 与DNS服务器 减少域名数， 并行加载， CDN 分发 缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage 渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline 负载均衡: DNS负载均衡、IP负载均衡、反向代理负载均衡等 Content-Typeapplication/x-www-form-urlencoded 表单发包 multipart/form-data 用在发送文件的POST包 raw 可以上传json,xml,文本等 https在http加入SSL层,是https安全的基础 数据传输之前双方的身份验证、协商加密算法、交换密钥 SSH非对称性加密，包括传输层，用户认证和连接协议 MD5MD5加密输出是32位字符串 1.SSL是一个独立的安全套层加密协议；位于TCP(应用层)和IP(网络层)之间；只是起到将数据加密和验证作用；2.SSH有加密，连接和认证功能，也是一种协议；3.md5只是简单讲数据加密传输或者被存贮到数据库；4.最本质的区别：SSL,SSH是一个协议,而md5是一种数据加密方式 原生http请求: 超文本传输协议1234let xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;, &apos;/list&apos;) xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/x-www-form-urlencoded&apos;) xhr.send() 200: 请求已经成功，请求所希望的响应头或者数据体将随着此响应返回 202: 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了 204: 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息 304: 被请求的资源内容没有发生更改 400: 包含语法错误，无法被服务器解析 403: 服务器已经接收请求，但是拒绝执行 404: 请求失败，请求所希望得到的资源未在服务器上发现 408: 请求超时。客户端可以再次提交这一请求而无需任何修改 500: 服务器内部错误，无法处理请求 502: 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效响应 504: 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://8899hudada.github.io/tags/http/"}]},{"title":"px2rem 以及 css模块化","slug":"px2rem-以及-css模块化","date":"2018-04-04T02:22:22.000Z","updated":"2018-06-11T02:27:21.851Z","comments":true,"path":"2018/04/04/px2rem-以及-css模块化/","link":"","permalink":"https://8899hudada.github.io/2018/04/04/px2rem-以及-css模块化/","excerpt":"","text":"px2rem自适应 { viewport 和 设备像素比调整基准像素 利用px2rem 自动转换rem}移动端 hotcss &gt; prem 像素 hotcss =&gt; webpack.config.js =&gt; entry: [‘./app/js/viewport.js’, ‘./app/js/main.js’] 项目组件化设计 css module 滑动 =&gt; vue-awesome-swiper复制路径 =&gt; copy-link-adress 1234567891011121314151617181920212223242526272829p &#123; /*均分两端对齐*/ justify-content: space-around; /*隐藏字体*/ text-overflow: ellipsis; white-space: nowrap; overflow: hidden;&#125;.content &#123; @include list(row) .item &#123; width: 50%; box-sizing: border-box; &amp;:first-child &#123; padding: 32px 20px; text-align: center; &#125;; &amp;:nth-child(3) &#123; &#125;; &amp;:nth-child(n + 3) &#123; &#125;; &amp;:last-child:after &#123; &#125; &#125;&#125;","categories":[],"tags":[{"name":"px2rem cssMoudle","slug":"px2rem-cssMoudle","permalink":"https://8899hudada.github.io/tags/px2rem-cssMoudle/"}]},{"title":"学习类Class简记","slug":"学习类Class简记","date":"2018-04-02T02:02:58.000Z","updated":"2018-06-11T05:59:32.218Z","comments":true,"path":"2018/04/02/学习类Class简记/","link":"","permalink":"https://8899hudada.github.io/2018/04/02/学习类Class简记/","excerpt":"","text":"类 ： class symbols objects decorators 1. class 一种原型链的语法糖12345678910111213141516171819class Fruit &#123; constructor(name, calories) &#123; this.name = name this.calories = calories this.pieces = 1 &#125; chop () &#123; this.pieces++ &#125; bite (person) &#123; if (this.piecess &lt; 1) return const calories = this.calories/this.pieces person.satiety += calories this.calories -= calories this.pieces-- &#125;&#125;util.inherits(Banana,Fruit) 2.symbols 协议/命名冲突123456const first = Symbol()object.getOwnPropertySymbol()Symbol.for(key) //获取symbolsSymbol.keyFor(symbol) // 来提取符号的keySymbol.match() // 正则Symbol.iterator 3.objects1234Object.assign(&#123;&#125;, options)Object.isObject.create() 4. js规范 保存函数功能的单一性 避免重复的代码async/await &gt; promiseEslint - plugin - prettier 1234[1, 2, 3, 4].map(item =&gt; item*2).filter(item =&gt; item &gt; 2).forEach(item =&gt; console.log(item))","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://8899hudada.github.io/tags/js/"}]},{"title":"webpack 打包配置NODE_ENV","slug":"webpack-打包配置NODE-ENV","date":"2018-04-01T01:43:01.000Z","updated":"2018-06-11T06:01:05.612Z","comments":true,"path":"2018/04/01/webpack-打包配置NODE-ENV/","link":"","permalink":"https://8899hudada.github.io/2018/04/01/webpack-打包配置NODE-ENV/","excerpt":"","text":"这是webpack打包时的主要两个功能： 清除dist文件 配置 dist 打包方式 npm run dev npm run build:test npm run build:prod 1.pakage.json安装相关功能的插件：devDependencies =&gt; {clean-webpack-plugin,cross-env} 2.webpack.base.config.js1234567891011121314modules.exports = &#123; output: &#123; path: path.join(__dirname, &apos;../dist&apos;), publicPath: &apos;/&apos; &#125;, plugins: [ new webpack.Provideplugin(&#123;&#125;), new webpack.DefinePlugin(&#123; &apos;process.env&apos;: &#123; NODE_ENV: JSON.stringify(process.env.NODE_ENV || &apos;development&apos;) &#125; &#125;) ]&#125; 3.webpack.prod.config.js12345678910111213const cleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)const Path = require(&apos;path&apos;)modules.exports = &#123; output: &#123; path: path.join(__dirname, &apos;../dist&apos;), publicPath: &apos;/dist/&apos; &#125;, plugins: [ new cleanWebpackPlugin([&apos;dist&apos;], &#123; root: path.resolve(__dirname, &apos;../dist&apos;) &#125;) ]&#125; 4.main.js 调用123456const baseUrl = &#123; development: &apos;--------&apos;, // 测试地址 production: &apos;--------&apos; // 生产地址&#125;baseUrl: baseUrl[process.env.NODE_ENV]","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://8899hudada.github.io/tags/webpack/"}]},{"title":"触摸事件","slug":"touchEvent","date":"2018-03-26T07:32:55.000Z","updated":"2018-06-11T06:00:28.813Z","comments":true,"path":"2018/03/26/touchEvent/","link":"","permalink":"https://8899hudada.github.io/2018/03/26/touchEvent/","excerpt":"","text":"1. 触摸事件touchstart touchmove touchend touchcanceltouches targetTouchs changeTouchs 2.常用属性bubble cancelable viewclientX clientY 浏览器中的X,YscreenX screenY 屏幕中的 X,YdetailaltKey shiftKey ctrKey metaKeypageX pageY 当前Dom中的X,Ytarget 触摸的Dom节点目标","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://8899hudada.github.io/tags/移动端/"}]},{"title":"vue基于viewer图片查看器","slug":"vue基于viewer图片查看器","date":"2018-03-08T03:47:14.000Z","updated":"2018-06-11T06:00:36.305Z","comments":true,"path":"2018/03/08/vue基于viewer图片查看器/","link":"","permalink":"https://8899hudada.github.io/2018/03/08/vue基于viewer图片查看器/","excerpt":"","text":"背景：公司正在用vue开发一款后台管理系统，有一个需求要查看图片：要求图片能够预览、放大、缩小、旋转、连续播放功能，写了很久都没能达到预想要求。 然后就在网上找相关插件，也没有找到vue相关的图片插件，情急之中就找到了一个JQ插件：viewer.js。于是乎就想着怎么把这个插件搬到vue组件里面来。 在vue里使用viewer.js====== 现在就有3个难题 ： 1.引入jQ 2.引入viewer 3.正确使用viewer 1.项目是用webpack打包的，引入jq、viewerjs网上案例很多，就直接上步骤 a.首先需要添加项目中jquery、viewerjs的依赖`npm install jquery viewerjs --save-dev` b.在build目录中配置webpack.base.config.js 1234567891011121314151617module: &#123; resolve: &#123; extensions: ['.js', '.vue'], alias: &#123; 'vue': 'vue/dist/vue.esm.js', '@': resolve('../src'), 'jquery': 'jquery' &#125; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: \"jquery\", jQuery: \"jquery\" &#125;) ], &#125; c.在.vue文件中引入 12import $ from 'jquery'import Viewer from 'viewerjs' ###2.项目中使用viewerjs #####html代码：1234567&lt;div style='display:none;'&gt; &lt;ul id=\"image\"&gt; &lt;li v-for='(item, index) in urlArr'&gt; &lt;img :src=\"item.url\" :alt=\"item.title\" :id='\"a\" + index' :key='index'&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; #####js代码：12345678910111213141516171819if(substr === 'jpg' || substr === 'png') &#123; //jpg png 图片 引用viewer.js let that = this; setTimeout(function () &#123; //生成viewer实例 var viewer = new Viewer(document.getElementById('image')); //点击当前图片触发展示当前图片的放大图 let imgIndex = 0; that.urlArr.map((item, index) =&gt; &#123; if ( item.url === url ) &#123; imgIndex = index &#125; &#125;) $('#a' + imgIndex).trigger(\"click\") &#125;, 200);&#125;else &#123; //这里检查是否是PDF word 等其他url 如果是则链接新的窗口打开查看 window.open(url,'_blank') &#125; #####注意事项： ######a.页面中隐藏有一个div，专门存放图片列表 urlArr ######b.动态获取、加载图片需要时间，这里设置setTimeout 200毫秒 ，this重新指向that ######c.动态绑定id，用jQ的trigger触发对应图片的 viewer ###参考文献 #####viewerjs使用手册","categories":[],"tags":[{"name":"vue viewer","slug":"vue-viewer","permalink":"https://8899hudada.github.io/tags/vue-viewer/"}]},{"title":"Hello World","slug":"hello-world","date":"2015-04-01T01:43:01.000Z","updated":"2018-06-11T05:59:15.989Z","comments":true,"path":"2015/04/01/hello-world/","link":"","permalink":"https://8899hudada.github.io/2015/04/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hello gitBlog","slug":"Hello-gitBlog","permalink":"https://8899hudada.github.io/tags/Hello-gitBlog/"}]}]}